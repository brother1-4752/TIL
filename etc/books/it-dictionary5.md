# EP26 정렬 알고리즘이 뭐죠?

- Sorting algorithm is a method that organizes a given set of data into a specific order, based on a certain criterion. Some examples of sorting algorithms include bubble sort, insertion sort, selection sort, merge sort, and quick sort.

## 각 알고리즘의 Use-Case

- Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. It is not efficient for large data sets, but it is easy to understand and implement.
- insertion sort is an efficient algorithm for small data sets, but it becomes less efficient as the size of the data set increases. It builds the final sorted list one item at a time by repeatedly removing one element from the input data and inserting it in the correct position.
- selection sort is an algorithm that repeatedly finds the minimum element from the unsorted part of the list and swap it with the first element of the unsorted part. It's efficient for small data sets but less efficient for large data sets
- merge sort is a divide and conquer algorithm that divides the input list into two sublists, recursively sort the sublists, and then merge the sublists to form the final sorted list. It is efficient for large data sets, and it's widely used in practice.
- Quick sort is a divide and conquer algorithm that selects a "pivot" element from the list and partition the other elements into two sublists, according to whether they are less than or greater than the pivot. It is efficient for large data sets and also widely used in practice.

# EP27 스택, 큐가 뭐죠?

- a stack is a linear data structure that follows the Last In First Out (LIFO) principle. This means that the last element added to the stack will be the first one to be removed. An example of a stack could be a stack of books where the last book added to the top of the stack would be the first one to be removed.
- A queue, on the other hand, is a linear data structure that follows the First In First Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed. An example of a queue could be a line of people waiting for a bus, where the person who arrived first will be the first one to board the bus.

# EP28 해시테이블이 뭐죠?

- A hash table, also known as a hash map, is a data structure that maps keys to values using a hash function. The hash function takes an input (or 'key'), and returns an index in the array/table where the corresponding value (or 'data') can be found or stored. The key-value pairs are stored in an array, and the index of the array is generated by the hash function.
- Hash tables are efficient for searching, inserting, and deleting elements in the table, with an average time complexity of O(1) for these operations. They can be implemented using an array, linked list or another data structure. They are widely used in various computer science and engineering applications, such as databases, compilers, and operating systems.

## O(1)?

- O(1) is used to describe the time complexity of an algorithm, which is a measure of how the running time of the algorithm grows as the size of the input data increases. It's also known as "constant time" complexity.
- An algorithm that has O(1) time complexity means that the running time of the algorithm will remain constant, regardless of the size of the input data. This means that the time it takes for the algorithm to complete will not increase as the size of the input data increases. For example, accessing an element in an array using an index is O(1) because the time it takes to access the element does not depend on the size of the array.
- It's important to note that O(1) time complexity is a best-case scenario, and in some cases, the actual time complexity might be different due to various factors like memory allocation, cache misses and other environmental factors.

## 해시테이블 구현 by JS

- Here is an example of a simple hash table implementation in JavaScript:

```jsx

class HashTable {
  constructor() {
    this.table = new Array(137);
    this.values = [];
  }

  put(key, data) {
    const pos = this.betterHash(key);
    if (this.table[pos] == undefined) {
      this.table[pos] = key;
      this.values[pos] = data;
    } else {
      let index = ++pos;
      while (this.table[index] != undefined) {
        index++;
      }
      this.table[index] = key;
      this.values[index] = data;
    }
  }

  get(key) {
    const hash = this.betterHash(key);
    if (hash > -1) {
      for (let i = hash; this.table[i] != undefined; i++) {
        if (this.table[i] === key) {
          return this.values[i];
        }
      }
    }
    return undefined;
  }

  betterHash(string) {
    const H = 37;
    let total = 0;
    for (let i = 0; i < string.length; i++) {
      total += H * total + string.charCodeAt(i);
    }
    total = total % this.table.length;
    if (total < 0) {
      total += this.table.length - 1;
    }
    return parseInt(total);
  }
}

```

- This is a basic hash table implementation that uses a simple hash function to map keys to positions in an array. The put() method is used to add key-value pairs to the table, and the get() method is used to retrieve the value associated with a given key. The betterHash() method is used to generate a unique index for each key, and it uses a simple formula to convert the key into a numeric value that can be used as an index in the array.
- It's important to note that this is a simple example, and in practice, hash tables are implemented using more complex methods like chaining and open addressing to handle collisions, and using more efficient hash functions like SHA or MurmurHash.

## this 키워드

- The this keyword in JavaScript is used to refer to the current object. It's used to access the properties and methods of an object from within the object's own methods. In the constructor of the HashTable class, this.table and this.values are properties of the object, and put, get, betterHash are methods of the object, so this keyword is used to access them.

---

- The **`this`** keyword is created when a constructor function is called, and it refers to the newly created object that is being constructed. In JavaScript, the **`this`** keyword is determined by how a function is called, not by where it is defined.
- In the case of a constructor function, the **`this`** keyword is automatically set to the new object that is being constructed when the constructor is called with the **`new`** keyword. Therefore, when properties and methods are assigned to **`this`** inside a constructor function, they are added to the new object being constructed.
- It's important to note that the **`this`** keyword can have different meanings in different contexts, and it can be different depending on the way the function is called, or in the case of arrow functions, **`this`** is lexically scoped, meaning that it refers to the context in which the function is defined, not where it is called.

## The case that a constructor is called

- A constructor function is called when the **`new`** keyword is used to create an instance of an object.
- Here's an example of how to create an instance of an object using a constructor function:

```jsx

class MyClass {
  constructor() {
    // constructor code here
  }
}

let myObject = new MyClass();

```

- In this example, the **`MyClass`** constructor function is called with the **`new`** keyword, which creates a new instance of the **`MyClass`** object. The new object is assigned to the variable **`myObject`**, and the constructor function is executed, executing any code inside the constructor function.
- It's important to note that if you don't use the **`new`** keyword when calling the constructor function, **`this`** will not refer to the new object and it will cause unexpected behavior, it's recommended to always use **`new`** keyword when calling constructor functions.

# Clean Code 5가지 팁

1. Use meaningful and descriptive variable and function names: Using descriptive and meaningful names for variables and functions can make your code much more readable and maintainable.
2. Keep your code organized and structured: Using a consistent indentation and formatting style, and grouping related code together can make your code easier to read and understand.
3. Avoid unnecessary complexity: Keep your code as simple as possible, by avoiding over-engineering and using simple solutions instead of complex ones.
4. Write comments and documentation: Writing clear and concise comments and documentation can help others understand your code, and make it easier to maintain and update.
5. Use established coding conventions and best practices: Following established coding conventions and best practices can help ensure that your code is readable, maintainable, and consistent with industry standards.
- It's important to note that these tips are not only to improve code quality but also to make it more readable and maintainable, which is essential when you or other developers need to come back to the code.
